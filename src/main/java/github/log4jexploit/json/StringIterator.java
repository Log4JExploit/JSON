package github.log4jexploit.json;

import github.log4jexploit.json.exceptions.EndReachedException;

import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;

public class StringIterator implements Iterator<Character> {

    private final char[] array;
    private int index = 0;


    public StringIterator(String string) {
        this.array = string.toCharArray();
    }


    @Override
    public boolean hasNext() {
        return index + 1 <= array.length - 1;
    }

    public boolean hasLast() {
        return index > 0;
    }

    /**
     * If a next character is present, this method will advance.
     * @return true if advanced, false otherwise
     */
    public boolean tryAdvance() {
        if(hasNext()) {
            advance();
            return true;
        }
        return false;
    }

    public char getLast() {
        if(hasLast())
            return array[index - 1];
        throw new EndReachedException();
    }

    /**
     * Positions this iterator at the first character
     */
    public void reset() {
        this.index = 0;
    }

    /**
     * Will attempt to skip <b>n</b> characters.
     * @throws EndReachedException when the character that was skipped to is out of bounds.
     */
    public void trySkip(int n) throws EndReachedException {
        this.index += n;
        if(this.index >= this.array.length)
            throw new EndReachedException();
    }

    /**
     * Advances this iterator by one character by calling next
     */
    public void advance() {
        next();
    }

    @Override
    public Character next() {
        if(!hasNext())
            throw new EndReachedException();

        char c = array[index];
        index++;
        return c;
    }

    /**
     * Retrieves the character at the current position without modifying the state of this iterator.
     * @return the character
     */
    public Character current() {
        if(this.index >= this.array.length)
            throw new EndReachedException();

        return array[index];
    }

    public Result expectCurrent(char expected) {
        return new Result(current() != expected);
    }

    /**
     * Expect a specific character sequence, overlapping from the current character<br>
     * forward.
     * @param sequence the expected sequence
     * @return the result of the operation
     * @throws EndReachedException if the end of stream was encountered unexpectedly
     */
    public Result expectSequence(String sequence) throws EndReachedException {
        StringIterator sequenceIterator = new StringIterator(sequence);
        do {
            expectCurrent(sequenceIterator.current());
            if(peek() == null && sequenceIterator.hasNext())
                throw new EndReachedException();
            if(sequenceIterator.hasNext()) {
                advance();
                sequenceIterator.advance();
            }
        } while (sequenceIterator.hasNext());

        return new Result(false);
    }

    /**
     * Expect one of the given characters
     * @param expected the set of characters
     */
    public Result expectCurrent(Set<Character> expected) {
        if(!expected.contains(current()))
            return new Result(true);
        return new Result(false);
    }

    /**
     * Peeks at the next character, if available.
     * @return the character, or null, if the end was reached.
     */
    public Character peek() {
        if(!hasNext())
            return null;
        return array[this.index + 1];
    }

    @Override
    public void remove() {
        throw new UnsupportedOperationException();
    }

    @Override
    public void forEachRemaining(Consumer<? super Character> action) {
        Iterator.super.forEachRemaining(action);
    }

    public void forEachEncountered(Consumer<? super Character> action) {
        for(int i = 0; i < index; i++) {
            action.accept(this.array[i]);
        }
    }

    public static class Result {
        private final boolean failed;
        private final Object result;

        public Result(boolean failed, Object result) {
            this.failed = failed;
            this.result = result;
        }

        public Result(boolean failed) {
            this.failed = failed;
            this.result = null;
        }

        public Result onFail(Runnable action) {
            if(failed) {
                action.run();
            }
            return this;
        }

        public Result onSuccess(Runnable action) {
            if(!failed) {
                action.run();
            }
            return this;
        }

        public Result anyway(Runnable action) {
            action.run();
            return this;
        }

        public Object get() {
            return result;
        }
    }
}
