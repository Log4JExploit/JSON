package github.log4jexploit.json;

import github.log4jexploit.json.exceptions.EndReachedException;

import java.util.Iterator;
import java.util.Set;
import java.util.function.Consumer;

public class StringIterator implements Iterator<Character> {

    private char[] array;
    private int index = 0;


    public StringIterator(String string) {
        this.array = string.toCharArray();
    }

    public StringIterator() {
        this.array = new char[0];
    }

    public void setArray(char[] array) {
        this.array = array;
        reset();
    }

    @Override
    public boolean hasNext() {
        return index + 1 < array.length;
    }

    public boolean hasLast() {
        return index > 0;
    }

    public boolean hasCurrent() {
        return this.index < array.length;
    }

    /**
     * If a next character is present, this method will advance.
     * @return true if advanced, false otherwise
     */
    public boolean tryAdvance() {
        if(hasNext()) {
            advance();
            return true;
        }
        return false;
    }

    public char getLast() {
        if(hasLast())
            return array[index - 1];
        throw new EndReachedException();
    }

    /**
     * Positions this iterator at the first character
     */
    public void reset() {
        this.index = 0;
    }

    /**
     * Will attempt to skip <b>n</b> characters.
     * @throws EndReachedException when the character that was skipped to is out of bounds.
     */
    public void trySkip(int n) throws EndReachedException {
        this.index += n;
        if(this.index >= this.array.length)
            throw new EndReachedException();
    }

    public void forward() {
        this.index++;
    }

    /**
     * Advances this iterator by one character by calling next
     */
    public void advance() {
        next();
    }

    @Override
    public Character next() {
        if(!hasNext())
            throw new EndReachedException();
        return array[index++];
    }

    /**
     * Retrieves the character at the current position without modifying the state of this iterator.
     * @return the character
     */
    public Character current() {
        if(this.index >= this.array.length)
            throw new EndReachedException();

        return array[index];
    }

    public Result<Character> expectCurrent(char expected) {
        if(current() != expected) {
            return Result.failed();
        }
        return Result.with(expected);
    }

    /**
     * Expect a specific character sequence, overlapping from the current character<br>
     * forward.
     * @param sequence the expected sequence
     * @return the result of the operation
     * @throws EndReachedException if the end of stream was encountered unexpectedly
     */
    public Result<?> expectSequence(String sequence) throws EndReachedException {
        StringIterator sequenceIterator = new StringIterator(sequence);
        do {
            expectCurrent(sequenceIterator.current());
            if(peek() == null && sequenceIterator.hasNext())
                throw new EndReachedException();
            if(sequenceIterator.hasNext()) {
                advance();
                sequenceIterator.advance();
            }
        } while (sequenceIterator.hasNext());

        return Result.with(null);
    }

    /**
     * Expect one of the given characters
     * @param expected the set of characters
     */
    public Result<Character> expectCurrent(Set<Character> expected) {
        if(!expected.contains(current()))
            return Result.failed();
        return Result.with(current());
    }

    /**
     * Peeks at the next character, if available.
     * @return the character, or null, if the end was reached.
     */
    public Character peek() {
        if(!hasNext())
            return null;
        return array[this.index + 1];
    }

    public StringIterator divergeAtCurrent() {
        StringIterator copy = new StringIterator(String.copyValueOf(this.array));
        copy.trySkip(this.index);
        return copy;
    }

    @Override
    public void remove() {
        throw new UnsupportedOperationException();
    }

    public int index() {
        return this.index;
    }

    public void setIndex(int index) {
        this.index = index;
    }

    public char[] chars() {
        return array;
    }

    @Override
    public void forEachRemaining(Consumer<? super Character> action) {
        Iterator.super.forEachRemaining(action);
    }

    public void forEachEncountered(Consumer<? super Character> action) {
        for(int i = 0; i <= index; i++) {
            action.accept(this.array[i]);
        }
    }

    public Iterable<Character> forEachReverse() {
        return () -> new Iterator<>() {
            private final char[] array = StringIterator.this.array;
            private int index = array.length-1;

            @Override
            public boolean hasNext() {
                return index >= 0;
            }

            @Override
            public Character next() {
                return array[index--];
            }
        };
    }

    public Iterable<Character> forEachInOrder() {
        return () -> new Iterator<>() {
            private final char[] array = StringIterator.this.array;
            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < array.length;
            }

            @Override
            public Character next() {
                return array[index++];
            }
        };
    }

    public Iterable<Character> forEachUntilIndex(int inclusive) {
        return () -> new Iterator<>() {
            private final char[] array = StringIterator.this.array;
            private final int size = Math.min(inclusive, array.length - 1);
            private int index = 0;

            @Override
            public boolean hasNext() {
                return index <= size;
            }

            @Override
            public Character next() {
                return array[index++];
            }
        };
    }
}
