package github.log4jexploit.json;

import github.log4jexploit.json.exceptions.EndReachedException;
import github.log4jexploit.json.exceptions.JSONParseException;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.List;

class JSONParser {

    private final char escape = '\\';
    private final char doubleQuote = '\"';

    private final List<Character> separators = List.of('\"','\'');
    private final List<Character> unicodes = List.of('\t', '\n', '\r');
    private final List<Character> spaces = List.of(' ', '\t', '\n', '\r');
    private final List<Character> digit = List.of('.','0','1','2','3','4','5','6','7','8','9','+','-','e','E');
    private final StringIterator iterator;


    /**
     * A helper class to convert a json text to a {@link JSONObject} or a {@link JSONArray}
     * @param text the text to parse
     */
    JSONParser(String text) {
        this.iterator = new StringIterator(text.trim());
    }


    /**
     * Parses the given JSON string into a usable {@link JSONObject} or {@link JSONArray}
     * object depending on the input.
     * @return the parsed {@link JSONAble}
     * @throws JSONParseException When an invalid character is encountered
     * @throws EndReachedException When the string ends unexpectedly
     */
    public JSONAble parse() throws JSONParseException, EndReachedException {
        char first = iterator.current();

        return switch (first) {
            case '{': yield parseObject();
            case '[': yield parseArray();
            default: this.onInvalidChar(); yield null;
        };
    }

    /**
     * Parses a JSON array and its contents.
     * @return the populated {@link JSONArray}
     * @throws JSONParseException When an invalid character is encountered
     * @throws EndReachedException When the string ends unexpectedly
     */
    private JSONArray parseArray() throws JSONParseException, EndReachedException {
        iterator.expectCurrent('[')
                .onFail(() -> onInvalidChar());

        iterator.advance();
        JSONArray array = new JSONArray();
        char insideArray = iterator.current();

        if(insideArray == ']') {
            iterator.advance();
            return array;
        }

        do {
            skipOptionalSpaces();

            Object o = parseValue();
            array.add(o);

            skipOptionalSpaces();

            if(iterator.current() == ',') {
                iterator.advance();
            }

            skipOptionalSpaces();
            insideArray = iterator.current();
        } while (insideArray != ']');

        if(iterator.hasNext())
            iterator.advance();

        return array;
    }

    /**
     * Parses the value assigned to a key inside a {@link JSONObject} or a value
     * inside a {@link JSONArray}.
     * @return the parsed value
     */
    private Object parseValue() {
        char firstSymbol = iterator.current();
        if(firstSymbol == '{') {
            return parseObject();
        } else if(firstSymbol == '[') {
            return parseArray();
        } else if(this.digit.contains(firstSymbol)) {
            return parseNumber();
        } else if(firstSymbol == doubleQuote) {
            return parseTextSequence();
        } else {
            String keyword = parseKeyword();
            return detectKeyword(keyword);
        }
    }

    /**
     * Detect the three allowed json keywords; true, false, null
     * @param keyword the text
     * @return the primitive representing the keyword, or null
     */
    private Object detectKeyword(String keyword) {
        return switch (keyword.toLowerCase()) {
            case "null": yield null;
            case "true": yield true;
            case "false": yield false;
            default: onUnexpected("Unknown keyword encountered: "+keyword); yield null;
        };
    }

    /**
     * Parses a text sequence only consisting of alphabetic characters. Expects to be positioned
     * on the first keyword character.
     * @return the keyword
     */
    private String parseKeyword() {
        StringBuilder buffer = new StringBuilder();
        do {
            char read = iterator.current();
            if(!Character.isAlphabetic(read)) {
                return buffer.toString();
            }
            buffer.append(read);
            if(!iterator.hasNext()) {
                return buffer.toString();
            }
            iterator.advance();
        } while (true);
    }

    /**
     * Parses a {@link JSONObject}. Expects to be positioned on the first curly bracket.
     * @return the parsed {@link JSONObject}
     */
    private JSONObject parseObject() {
        JSONObject jsonObject = new JSONObject();
        iterator.advance();

        while(iterator.current() != '}') {
            skipOptionalSpaces();
            iterator.expectCurrent(doubleQuote).onFail(() -> onInvalidChar());
            String keyText = parseTextSequence();

            iterator.expectCurrent(':').onFail(() -> onInvalidChar());
            iterator.advance();
            skipOptionalSpaces();

            Object value = parseValue();  // Parse map value
            jsonObject.put(keyText, value);

            skipOptionalSpaces();

            if(iterator.current() == ',') { // Skip comma separation, if present
                iterator.advance();
                skipOptionalSpaces();
            }
        }

        if(iterator.hasNext()) // Advance if this is not the outermost wrapper object
            iterator.advance();

        return jsonObject;
    }

    /**
     * Reads all characters associated with the number.
     * @return a text containing all number characters
     */
    private Number parseNumber() {
        if(!digit.contains(iterator.current()))
            onInvalidChar("Current character is not a digit");

        StringBuilder buffer = new StringBuilder();

        do {
            char current = iterator.next();
            buffer.append(current);
        } while (digit.contains(iterator.current()));

        return determineNumber(buffer.toString());
    }

    /**
     * Determines a given number from text input.
     * @param text the number in text form
     * @return the parsed number
     */
    private Number determineNumber(String text) {
        int count = count(text.toCharArray(), '.');

        if(count > 1) {
            onInvalidChar("Expected number, instead found: " + text);
        }

        if(count == 1) {
            return new BigDecimal(text);
        } else {
            return new BigInteger(text);
        }
    }

    /**
     * Parses a text sequence, expecting to be positioned at the first quotation mark.
     * The iterator will be positioned at the next character following the ending quotation.
     * @return the text sequence, excluding enclosing quotations
     */
    private String parseTextSequence() {
        char separator = iterator.next();
        if(!separators.contains(separator)) {
            onUnexpected("Current symbol is not a known quote: '"+separator+"'");
        }

        StringBuilder buffer = new StringBuilder();
        char next;
        do {
            next = iterator.current();

            if(next == escape) {
                iterator.advance();
                buffer.append(iterator.next());
                continue;
            }

            if(next != separator) {
                buffer.append(next);
                iterator.advance();
            }
        } while (next != separator);

        iterator.advance();
        return buffer.toString();
    }

    /**
     * Skips whitespaces and tabs, until a different character is encountered.
     * This method will return upon end of stream, instead of throwing an exception.
     */
    private void skipOptionalSpaces() {
        while(iterator.hasNext() && spaces.contains(iterator.current())) {
            iterator.advance();
        }
    }

    /**
     * Counts the occurrences of an individual character in a text sequence.
     * @param text the text sequence in which to search
     * @param character the character to look for
     * @return the amount
     */
    private static int count(char[] text, char character) {
        int count = 0;
        for (char b : text) {
            if (b == character) {
                count++;
            }
        }
        return count;
    }

    /**
     * Invoked when an unexpected character is encountered
     */
    public void onInvalidChar() throws JSONParseException {
        throw new JSONParseException("Unexpected character: "+this.iterator.current(), this.iterator);
    }

    /**
     * Invoked when an unexpected character is encountered
     */
    public void onInvalidChar(String message) throws JSONParseException {
        throw new JSONParseException(message + ": "+this.iterator.current(), this.iterator);
    }

    /**
     * Invoked when an unexpected character is encountered
     */
    public void onUnexpected(String message) throws JSONParseException {
        throw new JSONParseException(message, this.iterator);
    }
}
