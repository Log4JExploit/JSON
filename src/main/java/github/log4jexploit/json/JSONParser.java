package github.log4jexploit.json;

import github.log4jexploit.json.exceptions.EndReachedException;
import github.log4jexploit.json.exceptions.JSONParseException;
import github.log4jexploit.json.exceptions.JSONRecursionException;

import java.util.*;

class JSONParser {

    private final char escape = '\\';
    private final char doubleQuote = '\"';

    private final List<Character> separators = List.of(doubleQuote,'\'');
    private final List<Character> spaces = List.of(' ', '\t', '\n', '\r');
    private final List<Character> digit = List.of('.','0','1','2','3','4','5','6','7','8','9','+','-','e','E');

    private final List<Character> hex = List.of(
            '0','1','2','3','4','5','6','7','8','9',
            'A','B','C','D','E','F',
            'a','b','c','d','e','f'
    );

    private NumberParser numberParser;
    private StringIterator iterator;
    private int recursionDepth;


    /**
     * A helper class to convert a json text to a {@link JSONObject} or a {@link JSONArray}
     */
    JSONParser() {
        this.numberParser = new NumberParser();
        this.iterator = new StringIterator();
        this.recursionDepth = 0;
    }


    /**
     * Parses the given JSON string into a usable {@link JSONObject} or {@link JSONArray}
     * object depending on the input.
     * @param text the text to parse
     * @return the parsed {@link JSONAble}
     * @throws JSONParseException When an invalid character is encountered
     * @throws EndReachedException When the string ends unexpectedly
     */
    public JSONAble parse(String text) throws JSONParseException, EndReachedException {
        this.iterator.setArray(text.trim().toCharArray());
        char first = iterator.current();
        this.recursionDepth++;

        return switch (first) {
            case '{': yield parseObject();
            case '[': yield parseArray();
            default: this.onInvalidChar(); yield null;
        };
    }

    /**
     * Parses a JSON array and its contents.
     * @return the populated {@link JSONArray}
     * @throws JSONParseException When an invalid character is encountered
     * @throws EndReachedException When the string ends unexpectedly
     */
    private JSONArray parseArray() throws JSONParseException, EndReachedException {
        recursionDepth++;
        checkRecursionLimit();

        iterator.expectCurrent('[')
                .onFail(() -> onInvalidChar());
        iterator.advance();

        skipOptionalSpaces();

        JSONArray array = new JSONArray();
        char next = iterator.current();

        if(next == ']') {
            iterator.advance();
            return array;
        }

        do {
            skipOptionalSpaces();
            array.add(parseValue());
            skipOptionalSpaces();

            if(iterator.current() == ',') {
                iterator.advance();
            }

            skipOptionalSpaces();
            next = iterator.current();
        } while (next != ']');

        if(iterator.hasNext())
            iterator.advance();

        return array;
    }

    /**
     * Parses the value assigned to a key inside a {@link JSONObject} or a value
     * inside a {@link JSONArray}.
     * @return the parsed value
     */
    private Object parseValue() {
        char firstSymbol = iterator.current();
        if(firstSymbol == '{') {
            return parseObject();
        } else if(firstSymbol == '[') {
            return parseArray();
        } else if(this.digit.contains(firstSymbol)) {
            return parseNumber();
        } else if(firstSymbol == doubleQuote) {
            return parseTextSequence();
        } else {
            String keyword = parseKeyword();
            return detectKeyword(keyword);
        }
    }

    /**
     * Detect the three allowed json keywords; true, false, null
     * @param keyword the text
     * @return the primitive representing the keyword, or null
     */
    private Object detectKeyword(String keyword) {
        return switch (keyword.trim().toLowerCase()) {
            case "null": yield null;
            case "true": yield true;
            case "false": yield false;
            default: onUnexpected("Unknown keyword encountered: '"+keyword+"'!"); yield null;
        };
    }

    /**
     * Parses a text sequence only consisting of alphabetic characters. Expects to be positioned
     * on the first keyword character.
     * @return the keyword
     */
    private String parseKeyword() {
        StringBuilder buffer = new StringBuilder();
        do {
            char read = iterator.current();
            if(!Character.isAlphabetic(read)) {
                return buffer.toString();
            }
            buffer.append(read);
            if(!iterator.hasNext()) {
                return buffer.toString();
            }
            iterator.advance();
        } while (true);
    }

    /**
     * Parses a {@link JSONObject}. Expects to be positioned on the first curly bracket.
     * @return the parsed {@link JSONObject}
     */
    private JSONObject parseObject() {
        this.recursionDepth++;
        checkRecursionLimit();

        JSONObject jsonObject = new JSONObject();
        iterator.advance();

        skipOptionalSpaces();

        while(iterator.current() != '}') {
            skipOptionalSpaces();

            iterator.expectCurrent(doubleQuote).onFail(() -> onInvalidChar());
            String keyText = parseTextSequence();

            iterator.expectCurrent(':').onFail(() -> onInvalidChar());
            iterator.advance();

            skipOptionalSpaces();

            Object value = parseValue();  // Parse map value
            jsonObject.put(keyText, value);

            skipOptionalSpaces();

            if(iterator.current() == ',') { // Skip comma separation, if present
                iterator.advance();
                skipOptionalSpaces();
            }
        }

        if(iterator.hasNext()) // Advance if this is not the outermost wrapper object
            iterator.advance();

        return jsonObject;
    }

    private void checkRecursionLimit() {
        if(recursionDepth >= JSON.RECURSION_DEPTH_LIMIT) {
            throw new JSONRecursionException(iterator);
        }
    }

    /**
     * Reads all characters associated with the number.
     * @return a text containing all number characters
     */
    private Number parseNumber() {
        return this.numberParser.parse(this.iterator);
    }

    /**
     * Parses a text sequence, expecting to be positioned at the first quotation mark.
     * The iterator will be positioned at the next character following the ending quotation.
     * @return the text sequence, excluding enclosing quotations
     */
    private String parseTextSequence() {
        char separator = iterator.next();
        if(!separators.contains(separator)) {
            onUnexpected("Quote expected, instead found (dec value) '"+(int)separator+"'!");
        }

        StringBuilder buffer = new StringBuilder();
        char next;
        do {
            next = iterator.current();

            if(next == escape) {
                if(!iterator.hasNext()) {
                    throw new EndReachedException();
                }

                next = iterator.peek();

                switch (next) {
                    case '\"':
                    case '\\':
                    case '/':
                        buffer.append(next);
                        continue;

                    case 'b': buffer.append('\b'); continue;
                    case 'f': buffer.append('\f'); continue;
                    case 'n': buffer.append('\n'); continue;
                    case 'r': buffer.append('\r'); continue;
                    case 't': buffer.append('\t'); continue;

                    case 'u':
                        buffer.append(parseUnicode());
                        continue;

                    default:
                        onUnexpected("Expected (\", \\, /, b, f, n, r, t or u) instead found (dec value) '"+(int)next+"'!");
                        continue;
                }
            }

            if(next != separator) {
                if(next < 32) {
                    onUnexpected("Expected any non-control character, instead found (dec value) '"+(int)next+"'!");
                }
                buffer.append(next);
                iterator.advance();
            }
        } while (next != separator);

        iterator.advance();
        return buffer.toString();
    }

    /**
     * Parses the current unicode sequence, for example '/u0000', but with a backslash
     * @implNote IntelliJ Community Edition has trouble parsing unicode sequences
     * in comments and displaying them correctly.
     * @return the character represented by the unicode sequence
     */
    private char parseUnicode() {
        iterator.expectCurrent('\\');
        iterator.trySkip(2);

        int result = 0;
        char next;

        for(int i = 0; i < 4; i++) {
            next = Character.toUpperCase(iterator.current());

            int power = (int) Math.pow(16, 4 - (i+1));
            int value;

            if(next >= '0' && next <= '9') {
                value = ('0' - next);
            } else if(next >= 'A' && next <= 'F') {
                value = ('A' - next) + 10;
            } else {
                onUnexpected("Expected hex-digit, instead found (dec value) '"+(int)next+"'!");
                break;
            }

            result += power * value;
            iterator.advance();
        }

        return (char) result;
    }

    /**
     * Skips whitespaces and tabs, until a different character is encountered.
     * This method will return upon end of stream, instead of throwing an exception.
     */
    private void skipOptionalSpaces() {
        while(iterator.hasNext() && spaces.contains(iterator.current())) {
            iterator.advance();
        }
    }

    /**
     * Counts the occurrences of an individual character in a text sequence.
     * @param text the text sequence in which to search
     * @param character the character to look for
     * @return the amount
     */
    private static int count(char[] text, char character) {
        int count = 0;
        for (char b : text) {
            if (b == character) {
                count++;
            }
        }
        return count;
    }

    /**
     * Invoked when an unexpected character is encountered
     */
    public void onInvalidChar() throws JSONParseException {
        throw new JSONParseException("Unexpected character: "+this.iterator.current(), this.iterator);
    }

    /**
     * Invoked when an unexpected character is encountered
     */
    public void onUnexpected(String message) throws JSONParseException {
        throw new JSONParseException(message, this.iterator);
    }
}
