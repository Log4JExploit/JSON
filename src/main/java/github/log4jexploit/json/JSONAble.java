package github.log4jexploit.json;

import github.log4jexploit.json.exceptions.JSONRecursionException;

public interface JSONAble {


    String toJSONString();

    String toJSONString(int recursionDepth);

    boolean isArray();

    boolean isObject();

    JSONObject asObject();

    JSONArray asArray();

    static String toValueString(Object object) {
        if(object instanceof JSONAble obj) {
            return obj.toJSONString();
        } else if(object == null) {
            return "null";
        } else if(Primitives.isPrimitive(object)) {
            return object.toString();
        } else {
            return "\"" + escapeText(object.toString()) + "\"";
        }
    }

    static String toValueString(Object object, int recursionDepth) {
        if(object instanceof JSONAble obj) {
            if(recursionDepth >= JSON.RECURSION_DEPTH_LIMIT)
                throw new JSONRecursionException();
            return obj.toJSONString(recursionDepth + 1);
        } else if(object == null) {
            return "null";
        } else if(Primitives.isPrimitive(object)) {
            return object.toString();
        } else {
            return "\"" + escapeText(object.toString()) + "\"";
        }
    }


    static String escapeText(String text) {
        StringIterator iterator = new StringIterator(text);
        StringBuilder buffer = new StringBuilder();

        do {
            if(!iterator.hasCurrent()) {
                break;
            }

            final char current = iterator.current();

            if(current == '\"') {
                if(!iterator.hasLast() || iterator.getLast() != '\\') {
                    buffer.append("\\\"");
                    continue;
                }
            }

            if(current == '\\') {
                if (iterator.hasNext()) {
                    char peek = iterator.peek();
                    switch (peek) {
                        case '\"':
                        case '\\':
                        case '/':
                        case 'b':
                        case 'f':
                        case 'n':
                        case 'r':
                        case 't':
                            buffer.append("\\");
                            continue;
                        default:
                            buffer.append("\\\\");
                            break;
                    }
                } else {
                    buffer.append("\\\\");
                    continue;
                }
            }

            if(current < 32 || current > 126) {
                buffer.append(toUnicode(current));
                continue;
            }

            buffer.append(current);
        } while (iterator.tryAdvance());
        return buffer.toString();
    }

    /**
     * Constructs a unicode sequence using the given character
     * @param c the character to convert
     * @return the unicode sequence
     */
    static String toUnicode(char c) {
        StringBuilder builder = new StringBuilder();

        while(c > 0) {
            int hexDigit = c % 16;
            c /= 16;

            if(hexDigit < 10) {
                builder.append((char) ('0' + hexDigit));
            } else {
                hexDigit -= 10;
                builder.append((char) ('A' + hexDigit));
            }
        }

        while(builder.length() < 4) {
            builder.append('0');
        }

        builder.append("u\\");
        builder.reverse();
        return builder.toString();
    }
}
