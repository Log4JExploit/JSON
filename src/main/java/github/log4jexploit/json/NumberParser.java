package github.log4jexploit.json;


import github.log4jexploit.json.exceptions.EndReachedException;
import github.log4jexploit.json.exceptions.JSONParseException;


public class NumberParser {

    public static final char MINUS = '-';
    public static final char PLUS = '+';
    public static final char ZERO = '0';
    public static final char PERIOD = '.';

    private StringIterator iterator;
    private final NumberTemplate template;


    public NumberParser() {
        this.iterator = null;
        this.template = new NumberTemplate();
    }

    public Number parse(StringIterator iterator) {
        clear(iterator);
        template.negative = iterator.current() == MINUS;

        if (iterator.current() == PLUS || iterator.current() == MINUS) {
            iterator.forward();
        }

        char digit = iterator.current();
        Character peek = iterator.peek();

        if(!Character.isDigit(digit)) {
            throw new JSONParseException("Character is not a digit, was expecting a number: "+digit, iterator);
        }

        if(digit == ZERO && peek != null) {
            if(Character.isDigit(peek)) {
                throw new JSONParseException("A number cannot start with zero!", iterator);
            }
            if(peek == PERIOD) {
                iterator.trySkip(2);
            }
        }

        readAllDigits(
                iterator,
                digit == ZERO ? template.afterDecimalPoint : template.beforeDecimalPoint
        );

        if(!template.isDecimal() && iterator.current() == PERIOD) {
            if(!iterator.hasNext())
                throw new EndReachedException();
            if(Character.isDigit(iterator.peek())) {
                iterator.forward();
                readAllDigits(iterator, template.afterDecimalPoint);
            }
        }

        if(iterator.current() == 'e' || iterator.current() == 'E') {
            iterator.forward();
            char sign = expectSignCharacter();
            template.exponent.negative = sign == MINUS;

            if(!Character.isDigit(sign)) {
                iterator.forward();
            }

            if(!Character.isDigit(iterator.current()) || iterator.current() == ZERO) {
                throw new JSONParseException("Expected digits for exponent of number!", iterator);
            }

            readAllDigits(iterator, template.exponent.digits);
        }

        return assembleNumber();
    }

    public Number parse(String text) {
        StringIterator i = new StringIterator(text);
        Number parsed = parse(i);
        if (i.hasNext())
            throw new IllegalStateException("Unevaluated characters left!");
        return parsed;
    }

    private char expectSignCharacter() {
        if(iterator.current() == MINUS || iterator.current() == PLUS) {
            return iterator.current();
        }
        return PLUS;
    }

    private Number assembleNumber() {
        Number value;

        if (template.hasExponent()) {
            if (template.isDecimal()) {
                value = forDecimalExp();
            } else {
                value = forIntegerExp();
            }
        } else {
            if (template.isDecimal()) {
                value = forDecimal();
            } else {
                if (template.beforeDecimalPoint.length() > 19) {
                    throw new JSONParseException("Number exceeds digit limit of 19!", iterator);
                }
                value = forInteger();
            }
        }

        return value;
    }

    private void clear(StringIterator iterator) {
        this.iterator = iterator;
        this.template.afterDecimalPoint.setLength(0);
        this.template.beforeDecimalPoint.setLength(0);
        this.template.exponent.digits.setLength(0);
    }

    private double forDecimal() {
        double significant = (double) parseInteger(template.beforeDecimalPoint.toString());
        double insignificant = parseInsignificantDigits(template.afterDecimalPoint.toString());
        return (significant + insignificant) * (template.negative ? -1 : 1);
    }

    private long forInteger() {
        return parseInteger(template.beforeDecimalPoint.toString()) * (template.negative ? -1 : 1);
    }

    private double forDecimalExp() {
        long exponent = parseInteger(template.exponent.digits.toString());
        double significant = (double) parseInteger(template.beforeDecimalPoint.toString());
        double insignificant = parseInsignificantDigits(template.afterDecimalPoint.toString());
        double value = (significant + insignificant) * (template.negative ? -1 : 1);
        return Math.pow(10, template.exponent.negative ? -exponent : exponent) * value;
    }

    private Number forIntegerExp() {
        long exponent = parseInteger(template.exponent.digits.toString());
        long value = parseInteger(template.beforeDecimalPoint.toString()) * (template.negative ? -1 : 1);
        double pow = Math.pow(10, template.exponent.negative ? -exponent : exponent);
        double mul = value * pow;
        if(pow < 1 && mul != (long) mul) {
            return mul;
        }
        return (long) (pow * value);
    }

    private long parseInteger(String text) {
        long number = 0;
        int i = 0;

        while(i < text.length()) {
            number *= 10;
            number -= (text.charAt(i) - 48);
            i++;
        }

        return -number;
    }

    public double parseInsignificantDigits(String text) {
        double number = 0;
        int i = text.length() - 1;

        while(i >= 0) {
            number += (text.charAt(i) - ZERO);
            number /= 10.0;
            i--;
        }
        return number;
    }

    private void readAllDigits(StringIterator iterator, StringBuilder digits) {
        int index = iterator.index();
        char[] chars = iterator.chars();
        do {
            if(!Character.isDigit(chars[index])) {
                iterator.setIndex(index);
                return;
            }
            digits.append(chars[index]);
        } while (++index < chars.length);
        iterator.setIndex(index - 1);
    }

    public static class Exponent {
        StringBuilder digits = new StringBuilder();
        boolean negative = false;
    }

    public static class NumberTemplate {
        StringBuilder beforeDecimalPoint = new StringBuilder();
        StringBuilder afterDecimalPoint = new StringBuilder();
        boolean negative = false;
        Exponent exponent = new Exponent();

        private boolean isDecimal() {
            return !this.afterDecimalPoint.isEmpty();
        }

        private boolean hasExponent() {
            return !this.exponent.digits.isEmpty();
        }

        private boolean isNegative() {
            return !this.negative;
        }
    }
}
